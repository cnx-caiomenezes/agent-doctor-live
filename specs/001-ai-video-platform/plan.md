# Implementation Plan: AI-Powered Video/Audio Meeting Platform

**Feature Branch**: `001-ai-video-platform`  
**Created**: 2025-11-08  
**Status**: Phase 1 - Design & Contracts  
**Version**: 1.0.0

## Technical Context

### Technology Stack

#### Secretary Service (`agent-doctor-live/secretary`)

- **Runtime**: Node.js 24+
- **Language**: TypeScript (latest)
- **Web Framework**: Fastify (latest)
- **Database**: PostgreSQL (latest) via Fastify Postgres plugin
- **Cache**: Redis (latest)
- **Frontend**: HTMX (SSR - latest)
- **Validation**: Zod (latest)
- **Video Platform Integration**: LiveKit SDK (latest)
- **Purpose**: Meeting scheduling, participant management, authentication

#### Agent Service (`agent-doctor-live/agent`)

- **Runtime**: Node.js 24+
- **Language**: TypeScript (latest)
- **Database**: PostgreSQL (latest)
- **Cache**: Redis (latest)
- **AI Framework**: LiveKit Agents SDK (latest)
- **Purpose**: AI agent for contextual meeting assistance

#### Manager Service (`agent-doctor-live/manager`)

- **Runtime**: Node.js 24+
- **Language**: TypeScript (latest)
- **Web Framework**: Fastify (latest)
- **Database**: PostgreSQL (latest) via Fastify Postgres plugin
- **Cache**: Redis (latest)
- **Frontend**: HTMX (SSR - latest)
- **Validation**: Zod (latest)
- **Purpose**: Entity/organization configuration, user management

#### Meeting Server (`agent-doctor-live/meeting-server`)

- **Platform**: Self-hosted LiveKit Server
- **Orchestration**: Kubernetes
- **Containerization**: Docker
- **Purpose**: Real-time video/audio infrastructure

#### Room Client (`agent-doctor-live/room`)

- **Framework**: React 18+ (latest)
- **Language**: TypeScript (latest)
- **Video SDK**: LiveKit-client SDK (latest)
- **Styling**: TailwindCSS (latest)
- **Purpose**: Meeting room web interface

### Architecture Overview

```text
┌─────────────┐
│   Manager   │ ← Entity/Org Configuration (HTMX SSR)
│   (Fastify) │
└──────┬──────┘
       │
       ├───────→ PostgreSQL (Entities, Departments, Professionals, Users)
       └───────→ Redis (Sessions, Cache)

┌─────────────┐
│  Secretary  │ ← Meeting Scheduling (HTMX SSR)
│  (Fastify)  │
└──────┬──────┘
       │
       ├───────→ PostgreSQL (Rooms, Participants, Events, Usage)
       ├───────→ Redis (Realtime State)
       └───────→ LiveKit API (Create Rooms, Generate Tokens)

┌─────────────┐
│    Room     │ ← Meeting Participant Interface (React SPA)
│   (React)   │
└──────┬──────┘
       │
       └───────→ LiveKit Client SDK (WebRTC, Chat, Screen Share)
                       ↓
              ┌────────────────┐
              │ Meeting Server │ ← Self-hosted LiveKit
              │   (LiveKit)    │
              └────────┬───────┘
                       │
                       ├───────→ Redis (Room State)
                       └───────→ Agent Dispatch

┌─────────────┐
│    Agent    │ ← AI Assistant in Meeting
│ (LK Agents) │
└──────┬──────┘
       │
       ├───────→ LiveKit Agents SDK (Voice AI, Transcription)
       ├───────→ PostgreSQL (Agent Logs, Context)
       └───────→ Vector Database (Knowledge Base - TBD in research)
```

### Database Schema (PostgreSQL)

**Shared Database**: All services use the same PostgreSQL instance with logical separation via schemas or prefixed tables.

**Key Entities** (from spec.md):

- **Entity** (Manager): Organizations (clinics, companies)
- **Department** (Manager): Areas within entities (Cardiology, HR, etc)
- **Professional** (Manager): Doctors, consultants
- **User** (Manager): Backoffice users (MANAGER, ENTITY_ADMIN roles)
- **Room** (Secretary): Meeting rooms
- **Participant** (Secretary): Meeting participants (CLIENT, PROFESSIONAL, AGENT types)
- **RoomParticipant** (Secretary): Participant assignments to rooms
- **RoomEvent** (Secretary): General room events
- **AgentSessionEvent** (Secretary): AI agent session events
- **AgentUsage** (Secretary): Agent usage metrics

### Integration Points

1. **LiveKit Server**:
   - Room creation/management
   - Participant token generation
   - WebRTC SFU (Selective Forwarding Unit)
   - Agent dispatch triggers

2. **LiveKit Agents SDK**:
   - Voice AI processing
   - Transcription services
   - Context-aware responses
   - Vector database integration (for knowledge base)

3. **Authentication Flow**:
   - Manager: JWT-based authentication for admins
   - Secretary: Magic link + password (8 digits) for participants
   - Room: LiveKit access tokens generated by Secretary

4. **Communication Patterns**:
   - Manager ↔ Secretary: Shared PostgreSQL
   - Secretary ↔ LiveKit Server: REST API + WebSocket
   - Room ↔ LiveKit Server: WebRTC + WebSocket
   - Agent ↔ LiveKit Server: LiveKit Agents Protocol
   - Agent ↔ Secretary: PostgreSQL (logs, context retrieval)

### Unknowns Requiring Research

- **Vector Database Selection**: pgvector plugin
- **HTMX Patterns**: Best practices for HTMX with Fastify SSR for forms, validation, and real-time updates
- **LiveKit Deployment**: Production-ready Kubernetes deployment patterns for self-hosted LiveKit
- **Agent Context Management**: How to efficiently pass entity/department context to AI agents in real-time
- **Magic Link Security**: Best practices for magic link generation with Fastify and expiration handling
- **Participant Capacity Enforcement**: LiveKit-side enforcement vs application-side validation
- **Recording Storage**: Where to store recordings (S3, local volume, LiveKit egress?) and retention policy automation
- **Redis Usage Patterns**: Session management, caching strategy, and pub/sub for real-time updates

## Constitution Check

### Principle I: Code Minimalism ✅

- **Status**: Compliant
- **Rationale**: Monorepo structure with focused microservices. Each service has single responsibility. No code duplication between services - shared types will be in a common package.

### Principle II: Data Source Agnosticism ✅

- **Status**: Compliant
- **Rationale**: Repository pattern for all data access. Fastify Postgres plugin abstracts database implementation. Redis and PostgreSQL access wrapped in interfaces.

### Principle III: Test-Driven Quality ✅

- **Status**: Compliant
- **Plan**: Jest for all Node.js services, React Testing Library for Room. Critical paths (authentication, room creation, token generation) will have 100% coverage. Mocking external services (LiveKit API, Redis, PostgreSQL).

### Principle IV: Developer Experience First ✅

- **Status**: Compliant
- **Plan**: Docker Compose for all services + dependencies. Single command to start all services in debug mode. Hot reload enabled for all dev environments. Unified error handling across services. Pre-commit hooks for linting and type checking.

### Principle V: Performance by Design ✅

- **Status**: Compliant
- **Plan**: API endpoints target < 200ms p95. Redis for session/cache. PostgreSQL query optimization with indexes. Async/await for all I/O. LiveKit handles WebRTC performance (< 50ms latency requirement).

### Principle VI: API Security (OWASP) ✅

- **Status**: Compliant
- **Plan**:
  - JWT authentication (RS256) for Manager/Secretary APIs
  - Magic link + 8-digit password for participants
  - Zod validation at API boundaries
  - Rate limiting via Fastify plugins
  - HTTPS only (TLS 1.3)
  - Secrets via environment variables
  - RBAC for Manager (MANAGER, ENTITY_ADMIN roles)
  - LiveKit token-based access control for Room
  - Audit logging for authentication/authorization events
  - No credentials in code or committed .env files

### Gate Evaluation

**PASS** ✅ - All constitutional principles are addressed in the technical design.

---

## Phase 0: Research & Decisions

### Research Tasks

1. **Vector Database for AI Knowledge Base**
   - **Question**: Which vector DB optimizes for real-time agent context retrieval?
   - **Options**: pgvector (PostgreSQL extension), Pinecone (managed), Weaviate (self-hosted), Qdrant
   - **Criteria**: Latency < 50ms, supports semantic search, easy integration with Node.js

2. **HTMX + Fastify Patterns**
   - **Question**: How to structure HTMX forms with Fastify SSR and Zod validation?
   - **Research**: HTMX attribute patterns (hx-post, hx-swap), Fastify view rendering, error handling UX

3. **LiveKit Self-Hosting Production Best Practices**
   - **Question**: Kubernetes deployment, scaling, and monitoring for LiveKit
   - **Research**: Official LiveKit Helm charts, ingress configuration, Redis for distributed state

4. **Agent Context Passing**
   - **Question**: How to pass entity default instructions + department instructions + knowledge base to agent in real-time?
   - **Research**: LiveKit Agents SDK context injection, metadata passing, database query optimization

5. **Magic Link Implementation**
   - **Question**: Secure magic link generation, expiration handling, and validation with Fastify
   - **Research**: Token generation (JWT vs UUID), expiration strategies (Redis TTL), security best practices

6. **Participant Capacity Enforcement**
   - **Question**: Enforce at LiveKit server level or application level?
   - **Research**: LiveKit Room API limits, webhook-based validation vs pre-flight checks

7. **Recording Management**
   - **Question**: Storage backend and automatic retention policy implementation
   - **Research**: LiveKit Egress API, S3 integration, retention automation (cron jobs vs database triggers)

8. **Redis Patterns for Realtime**
   - **Question**: Session management, caching, pub/sub architecture for multi-service coordination
   - **Research**: Redis best practices with Fastify, session store plugins, pub/sub patterns

---

## Phase 1: Design & Contracts

### Data Model

**Output**: `data-model.md` with all entities, fields, relationships, validation rules

**Entities** (detailed in data-model.md):

1. **User** (Manager) - Backoffice authentication
2. **Entity** (Manager) - Organizations
3. **Department** (Manager) - Organizational units
4. **Professional** (Manager) - Staff members
5. **ProfessionalEntity** (Manager) - N:N relationship
6. **Room** (Secretary) - Meeting rooms
7. **Participant** (Secretary) - Generic participants
8. **RoomParticipant** (Secretary) - Room assignments
9. **RoomEvent** (Secretary) - Event logs
10. **AgentSessionEvent** (Secretary) - AI agent logs
11. **AgentUsage** (Secretary) - Usage metrics

### API Contracts

**Output**: OpenAPI schemas in `/contracts/` directory

**Manager API** (`/contracts/manager-api.yaml`):

- `POST /api/v1/auth/login` - Admin authentication
- `GET /api/v1/entities` - List entities
- `POST /api/v1/entities` - Create entity
- `PUT /api/v1/entities/:id` - Update entity
- `GET /api/v1/entities/:id/departments` - List departments
- `POST /api/v1/entities/:id/departments` - Create department
- `GET /api/v1/professionals` - List professionals
- `POST /api/v1/professionals` - Create professional
- `POST /api/v1/knowledge-base/upload` - Upload documents to vector DB

**Secretary API** (`/contracts/secretary-api.yaml`):

- `POST /api/v1/rooms` - Schedule meeting
- `GET /api/v1/rooms/:id` - Get meeting details
- `DELETE /api/v1/rooms/:id` - Cancel meeting
- `POST /api/v1/rooms/:id/participants` - Add participant
- `GET /api/v1/magic-link/validate` - Validate magic link
- `POST /api/v1/rooms/:id/join` - Generate LiveKit token
- `GET /api/v1/rooms/:id/recordings` - List recordings
- `GET /api/v1/agent-usage` - Metrics endpoint

**LiveKit Integration** (no OpenAPI - uses LiveKit SDK):

- Room management via SDK
- Token generation via SDK
- Webhook handling for events

**Room Client** (no REST API - direct LiveKit WebSocket):

- Connects to LiveKit Server with access token
- WebRTC for audio/video
- WebSocket for chat and events

### Quickstart Guide

**Output**: `quickstart.md` with developer setup instructions

**Contents**:

1. Prerequisites (Node.js 24+, Docker, PostgreSQL client)
2. Clone and install
3. Docker Compose setup (PostgreSQL, Redis, LiveKit)
4. Environment variables template
5. Database migrations
6. Start all services in dev mode (single command)
7. Access URLs for each service
8. Postman collection for API testing
9. Troubleshooting common issues

---

## Phase 2: Implementation Planning (Out of Scope for This Command)

*This phase will be executed in a separate command after Phase 0 and Phase 1 are complete.*

---

## Artifacts Generated

- ✅ **plan.md** (this file)
- ⏳ **research.md** (Phase 0 output - pending)
- ⏳ **data-model.md** (Phase 1 output - pending)
- ⏳ **contracts/manager-api.yaml** (Phase 1 output - pending)
- ⏳ **contracts/secretary-api.yaml** (Phase 1 output - pending)
- ⏳ **quickstart.md** (Phase 1 output - pending)
- ⏳ **.github/copilot-instructions.md** (Phase 1 output - pending update)

---

## Next Steps

1. **Execute Phase 0**: Run research tasks to resolve all NEEDS CLARIFICATION
2. **Execute Phase 1**: Generate data-model.md, API contracts, and quickstart guide
3. **Update Agent Context**: Run `.specify/scripts/bash/update-agent-context.sh copilot`
4. **Re-evaluate Constitution**: Verify all decisions align with constitution post-design

**Command Status**: ✅ **SETUP COMPLETE** - Ready for Phase 0 execution
